% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bsnsing.R
\name{bslearn}
\alias{bslearn}
\title{Find the Optimal Boolean Rule for Binary Classification}
\usage{
bslearn(bx, y, control = bscontrol())
}
\arguments{
\item{bx}{a data frame with binary (0 and 1) entries.}

\item{y}{an integer vector with binary entries.}

\item{control}{an object of class \code{bscontrol()}, specifying the algorithmic parameters. The list should contain the following attributes: \emph{lambda}, the penalty factor on the L1 norm of the solution, \emph{max.rules}, the maximum L1 norm of the solution, \emph{epsilon}, a small positive number serving as the threshold for numerical zero, \emph{bigM}, a positive integer serving as the big M in a MIP formulation, \emph{opt.model}, a character string in {\code{'mip', 'lp', 'hybrid'}} indicating the type of optimization model to solve, \emph{opt.solver}, a character string in {\code{'cplex', 'lpSolve'}} indicating the optimization solver to use.}
}
\value{
a list containing the splitting solution.
}
\description{
The function solves a mixed integer program (MIP) or a linear program (LP) to minimize the sum of two terms: the number of misclassifications (false positives and false negatives), and \code{lambda} times the L1 norm of the solution vector. The solution vector is of length \code{ncol(bx)}. In an LP, its elements are between 0 and 1; in a MIP, its elements are binary. The L1 norm of the solution vector is constrained to be less than or equal to \code{max.rules}. The optimal rule serves as the split condition in the classification tree built by \code{\link{bsnsing}}.
}
\examples{
data(Auto, package = 'ISLR')
x <- Auto[, c('mpg', 'cylinders', 'displacement')]
y <- ifelse(Auto$origin == 1, 1, 0)
# binarize x by y = 1
bx <- binarize(x, y, target = 1)
# learn the optimal Boolean rule
bssol <- bslearn(bx, y)
cat(paste("Optimal rule:" , bssol$rules, "\\n"))
bssol$confusion.matrix
}
